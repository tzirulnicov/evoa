.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::DAV 3pm"
.TH HTTP::DAV 3pm "2012-03-24" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::DAV \- A WebDAV client library for Perl5
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&   # DAV script that connects to a webserver, safely makes 
\&   # a new directory and uploads all html files in 
\&   # the /tmp directory.
\&
\&   use HTTP::DAV;
\&  
\&   $d = HTTP::DAV\->new();
\&   $url = "http://host.org:8080/dav/";
\& 
\&   $d\->credentials(
\&      \-user  => "pcollins",
\&      \-pass  => "mypass", 
\&      \-url   => $url,
\&      \-realm => "DAV Realm"
\&   );
\& 
\&   $d\->open( \-url => $url )
\&      or die("Couldn\*(Aqt open $url: " .$d\->message . "\en");
\& 
\&   # Make a null lock on newdir
\&   $d\->lock( \-url => "$url/newdir", \-timeout => "10m" ) 
\&      or die "Won\*(Aqt put unless I can lock for 10 minutes\en";
\&
\&   # Make a new directory
\&   $d\->mkcol( \-url => "$url/newdir" )
\&      or die "Couldn\*(Aqt make newdir at $url\en";
\&  
\&   # Upload multiple files to newdir.
\&   if ( $d\->put( \-local => "/tmp/*.html", \-url => $url ) ) {
\&      print "successfully uploaded multiple files to $url\en";
\&   } else {
\&      print "put failed: " . $d\->message . "\en";
\&   }
\&  
\&   $d\->unlock( \-url => $url );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1HTTP::DAV\s0 is a Perl \s-1API\s0 for interacting with and modifying content on webservers using the WebDAV protocol. Now you can \s-1LOCK\s0, \s-1DELETE\s0 and \s-1PUT\s0 files and much more on a DAV-enabled webserver.
.PP
\&\s-1HTTP::DAV\s0 is part of the PerlDAV project hosted at http://www.webdav.org/perldav/ and has the following features:
.IP "\(bu" 4
Full \s-1RFC2518\s0 method support. \s-1OPTIONS\s0, \s-1TRACE\s0, \s-1GET\s0, \s-1HEAD\s0, \s-1DELETE\s0, \s-1PUT\s0, \s-1COPY\s0, \s-1MOVE\s0, \s-1PROPFIND\s0, \s-1PROPPATCH\s0, \s-1LOCK\s0, \s-1UNLOCK\s0.
.IP "\(bu" 4
A fully object-oriented \s-1API\s0.
.IP "\(bu" 4
Recursive \s-1GET\s0 and \s-1PUT\s0 for site backups and other scripted transfers.
.IP "\(bu" 4
Transparent lock handling when performing \s-1LOCK/COPY/UNLOCK\s0 sequences.
.IP "\(bu" 4
http and https support (https requires the Crypt::SSLeay library). See \s-1INSTALLATION\s0.
.IP "\(bu" 4
Basic \s-1AND\s0 Digest authentication support (Digest auth requires the \s-1MD5\s0 library). See \s-1INSTALLATION\s0.
.IP "\(bu" 4
\&\f(CW\*(C`dave\*(C'\fR, a fully-functional ftp-style interface written on top of the \s-1HTTP::DAV\s0 \s-1API\s0 and bundled by default with the \s-1HTTP::DAV\s0 library. (If you've already installed \s-1HTTP::DAV\s0, then dave will also have been installed (probably into /usr/local/bin). You can see it's man page by typing \*(L"perldoc dave\*(R" or going to http://www.webdav.org/perldav/dave/.
.IP "\(bu" 4
It is built on top of the popular \s-1LWP\s0 (Library for \s-1WWW\s0 access in Perl). This means that \s-1HTTP::DAV\s0 inherits proxy support, redirect handling, basic (and digest) authorization and many other \s-1HTTP\s0 operations. See \f(CW\*(C`LWP\*(C'\fR for more information.
.IP "\(bu" 4
Popular server support. \s-1HTTP::DAV\s0 has been tested against the following servers: mod_dav, \s-1IIS5\s0, Xythos webfile server and mydocsonline. The library is growing an impressive interoperability suite which also serves as useful \*(L"sample scripts\*(R". See \*(L"make test\*(R" and t/*.
.PP
\&\f(CW\*(C`HTTP::DAV\*(C'\fR essentially has two \s-1API\s0's, one which is accessed through this module directly (\s-1HTTP::DAV\s0) and is a simple abstraction to the rest of the HTTP::DAV::* Classes. The other interface consists of the HTTP::DAV::* classes which if required allow you to get \*(L"down and dirty\*(R" with your \s-1DAV\s0 and \s-1HTTP\s0 interactions.
.PP
The methods provided in \f(CW\*(C`HTTP::DAV\*(C'\fR should do most of what you want. If, however, you need more control over the client's operations or need more info about the server's responses then you will need to understand the rest of the HTTP::DAV::* interfaces. A good place to start is with the \f(CW\*(C`HTTP::DAV::Resource\*(C'\fR and \f(CW\*(C`HTTP::DAV::Response\*(C'\fR documentation.
.SH "METHODS"
.IX Header "METHODS"
.SS "\s-1METHOD\s0 \s-1CALLING:\s0 Named vs Unnamed parameters"
.IX Subsection "METHOD CALLING: Named vs Unnamed parameters"
You can pass parameters to \f(CW\*(C`HTTP::DAV\*(C'\fR methods in one of two ways: named or unnamed.
.PP
Named parameters provides for a simpler/easier to use interface. A named interface affords more readability and allows the developer to ignore a specific order on the parameters. (named parameters are also case insensitive)
.PP
Each argument name is preceded by a dash.  Neither case nor order matters in the argument list.  \-url, \-Url, and \-URL are all acceptable.  In fact, only the first argument needs to begin with a dash.  If a dash is present in the first argument, \f(CW\*(C`HTTP::DAV\*(C'\fR assumes dashes for the subsequent ones.
.PP
Each method can also be called with unnamed parameters which often makes sense for methods with only one parameter. But the developer will need to ensure that the parameters are passed in the correct order (as listed in the docs).
.PP
.Vb 7
\& Doc:     method( \-url=>$url, [\-depth=>$depth] )
\& Named:   $d\->method( \-url=>$url, \-depth=>$d ); # VALID
\& Named:   $d\->method( \-Depth=>$d, \-Url=>$url ); # VALID
\& Named:   $d\->method( Depth=>$d,  Url=>$url );  # INVALID (needs \-)
\& Named:   $d\->method( \-Arg2=>$val2 ); # INVALID, ARG1 is not optional
\& Unnamed: $d\->method( $val1 );        # VALID
\& Unnamed: $d\->method( $val2,$val1 );  # INVALID, ARG1 must come first.
.Ve
.PP
\&\s-1IMPORTANT\s0 \s-1POINT\s0!!!! If you specify a named parameter first but then forget for the second and third parameters, you \s-1WILL\s0 get weird things happen. E.g. this is bad:
.PP
.Vb 1
\& $d\->method( \-url=>$url, $arg2, $arg3 ); # BAD BAD BAD
.Ve
.SS "\s-1THINGS\s0 \s-1YOU\s0 \s-1NEED\s0 \s-1TO\s0 \s-1KNOW\s0"
.IX Subsection "THINGS YOU NEED TO KNOW"
In all of the methods specified in \*(L"\s-1PUBLIC\s0 \s-1METHODS\s0\*(R" there are some common concepts you'll need to understand:
.IP "\(bu" 4
URLs represent an absolute or relative \s-1URI\s0.
.Sp
.Vb 3
\&  \-url=>"host.org/dav_dir/"  # Absolute
\&  \-url=>"/dav_dir/"          # Relative
\&  \-url=>"file.txt"           # Relative
.Ve
.Sp
You can only use a relative \s-1URL\s0 if you have already \*(L"open\*(R"ed an absolute \s-1URL\s0.
.Sp
The \s-1HTTP::DAV\s0 module now consistently uses the named parameter: \s-1URL\s0. The lower-level HTTP::DAV::Resource interface inconsistently interchanges \s-1URL\s0 and \s-1URI\s0. I'm working to resolve this, in the meantime, you'll just need to remember to use the right one by checking the documentation if you need to mix up your use of both interfaces.
.IP "\(bu" 4
\&\s-1GLOBS\s0
.Sp
Some methods accept wildcards in the \s-1URL\s0. A wildcard can be used to indicate that the command should perform the command on all Resources that match the wildcard. These wildcards are called \s-1GLOBS\s0.
.Sp
The glob may contain the characters \*(L"*\*(R", \*(L"?\*(R" and the set operator \*(L"[...]\*(R" where ... contains multiple characters ([1t2]) or a range such ([1\-5]). For the curious, the glob is converted to a regex and then matched: \*(L"*\*(R" to \*(L".*\*(R", \*(L"?\*(R" to \*(L".\*(R", and the [] is left untouched.
.Sp
It is important to note that globs only operate at the leaf-level. For instance \*(L"/my_dir/*/file.txt\*(R" is not a valid glob.
.Sp
If a glob matches no \s-1URL\s0's the command will fail (which normally means returns 0).
.Sp
Globs are useful in conjunction with \s-1CALLBACKS\s0 to provide feedback as each operation completes.
.Sp
See the documentation for each method to determine whether it supports globbing.
.Sp
Globs are useful for interactive style applications (see the source code for \f(CW\*(C`dave\*(C'\fR as an example).
.Sp
Example globs:
.Sp
.Vb 3
\&   $dav1\->delete(\-url=>"/my_dir/file[1\-3]");     # Matches file1, file2, file3
\&   $dav1\->delete(\-url=>"/my_dir/file[1\-3]*.txt");# Matches file1*.txt,file2*.txt,file3*.txt
\&   $dav1\->delete(\-url=>"/my_dir/*/file.txt");    # Invalid. Can only match at leaf\-level
.Ve
.IP "\(bu" 4
\&\s-1CALLBACKS\s0
.Sp
Callbacks are used by some methods (primarily get and put) to give the caller some insight as to how the operation is progressing. A callback allows you to define a subroutine as defined below and pass a reference (\e&ref) to the method.
.Sp
The rationale behind the callback is that a recursive get/put or an operation against many files (using a \f(CW\*(C`glob\*(C'\fR) can actually take a long time to complete.
.Sp
Example callback:
.Sp
.Vb 1
\&   $d\->get( \-url=>$url, \-to=>$to, \-callback=>\e&mycallback );
.Ve
.Sp
Your callback function \s-1MUST\s0 accept arguments as follows:
   sub cat_callback {
      my($status,$mesg,$url,$so_far,$length,$data) = \f(CW@_\fR;
      ...
   }
.Sp
The \f(CW\*(C`status\*(C'\fR argument specifies whether the operation has succeeded (1), failed (0), or is in progress (\-1).
.Sp
The \f(CW\*(C`mesg\*(C'\fR argument is a status message. The status message could contain any string and often contains useful error messages or success messages.
.Sp
The \f(CW\*(C`url\*(C'\fR the remote \s-1URL\s0.
.Sp
The \f(CW\*(C`so_far\*(C'\fR, \f(CW\*(C`length\*(C'\fR \- these parameters indicate how many bytes have been downloaded and how many we should expect. This is useful for doing \*(L"56% to go\*(R" style-gauges.
.Sp
The \f(CW\*(C`data\*(C'\fR parameter \- is the actual data transferred. The \f(CW\*(C`cat\*(C'\fR command uses this to print the data to the screen. This value will be empty for \f(CW\*(C`put\*(C'\fR.
.Sp
See the source code of \f(CW\*(C`dave\*(C'\fR for a useful sample of how to setup a callback.
.Sp
Note that these arguments are \s-1NOT\s0 named parameters.
.Sp
All error messages set during a \*(L"multi-operation\*(R" request (for instance a recursive get/put) are also retrievable via the \f(CW\*(C`errors()\*(C'\fR function once the operation has completed. See \f(CW\*(C`ERROR HANDLING\*(C'\fR for more information.
.SS "\s-1PUBLIC\s0 \s-1METHODS\s0"
.IX Subsection "PUBLIC METHODS"
.IP "\fBnew(\s-1USERAGENT\s0)\fR" 4
.IX Item "new(USERAGENT)"
.PD 0
.IP "\fBnew(\s-1USERAGENT\s0, \s-1HEADERS\s0)\fR" 4
.IX Item "new(USERAGENT, HEADERS)"
.PD
Creates a new \f(CW\*(C`HTTP::DAV\*(C'\fR client
.Sp
.Vb 1
\& $d = HTTP::DAV\->new();
.Ve
.Sp
The \f(CW\*(C`\-useragent\*(C'\fR parameter allows you to pass your own \fBuser agent object\fR and expects an \f(CW\*(C`HTTP::DAV::UserAgent\*(C'\fR object. See the \f(CW\*(C`dave\*(C'\fR program for an advanced example of a custom UserAgent that interactively prompts the user for their username and password.
.Sp
The \f(CW\*(C`\-headers\*(C'\fR parameter allows you to specify a list of headers to be sent along with all requests. This can be either a hashref like:
.Sp
.Vb 1
\&  { "X\-My\-Header" => "value", ... }
.Ve
.Sp
or a HTTP::Headers object.
.IP "\fBcredentials(\s-1USER\s0,PASS,[\s-1URL\s0],[\s-1REALM\s0])\fR" 4
.IX Item "credentials(USER,PASS,[URL],[REALM])"
sets authorization credentials for a \f(CW\*(C`URL\*(C'\fR and/or \f(CW\*(C`REALM\*(C'\fR.
.Sp
When the client hits a protected resource it will check these credentials to see if either the \f(CW\*(C`URL\*(C'\fR or \f(CW\*(C`REALM\*(C'\fR match the authorization response.
.Sp
Either \f(CW\*(C`URL\*(C'\fR or \f(CW\*(C`REALM\*(C'\fR must be provided.
.Sp
returns no value
.Sp
Example:
.Sp
.Vb 3
\& $d\->credentials( \-url=>\*(Aqmyhost.org:8080/test/\*(Aq,
\&                  \-user=>\*(Aqpcollins\*(Aq,
\&                  \-pass=>\*(Aqmypass\*(Aq);
.Ve
.IP "\fBDebugLevel($val)\fR" 4
.IX Item "DebugLevel($val)"
sets the debug level to \f(CW$val\fR. 0=off 3=noisy.
.Sp
\&\f(CW$val\fR default is 0.
.Sp
returns no value.
.Sp
When the value is greater than 1, the \f(CW\*(C`HTTP::DAV::Comms\*(C'\fR module will log all of the client<=>server interactions into /tmp/perldav_debug.txt.
.SS "\s-1DAV\s0 \s-1OPERATIONS\s0"
.IX Subsection "DAV OPERATIONS"
For all of the following operations, \s-1URL\s0 can be absolute (http://host.org/dav/) or relative (../dir2/). The only operation that requires an absolute \s-1URL\s0 is open.
.IP "\fBcopy(\s-1URL\s0,DEST,[\s-1OVERWRITE\s0],[\s-1DEPTH\s0])\fR" 4
.IX Item "copy(URL,DEST,[OVERWRITE],[DEPTH])"
copies one remote resource to another
.RS 4
.ie n .IP """\-url""" 4
.el .IP "\f(CW\-url\fR" 4
.IX Item "-url"
is the remote resource you'd like to copy. Mandatory
.ie n .IP """\-dest""" 4
.el .IP "\f(CW\-dest\fR" 4
.IX Item "-dest"
is the remote target for the copy command. Mandatory
.ie n .IP """\-overwrite""" 4
.el .IP "\f(CW\-overwrite\fR" 4
.IX Item "-overwrite"
optionally indicates whether the server should fail if the target exists. Valid values are \*(L"T\*(R" and \*(L"F\*(R" (1 and 0 are synonymous). Default is T.
.ie n .IP """\-depth""" 4
.el .IP "\f(CW\-depth\fR" 4
.IX Item "-depth"
optionally indicates whether the server should do a recursive copy or not. Valid values are 0 and (1 or \*(L"infinity\*(R"). Default is \*(L"infinity\*(R" (1).
.RE
.RS 4
.Sp
The return value is always 1 or 0 indicating success or failure.
.Sp
Requires a working resource to be set before being called. See \f(CW\*(C`open\*(C'\fR.
.Sp
Note: if either \f(CW\*(AqURL\*(Aq\fR or \f(CW\*(AqDEST\*(Aq\fR are locked by this dav client, then the lock headers will be taken care of automatically. If the either of the two \s-1URL\s0's are locked by someone else, the server should reject the request.
.Sp
\&\fBcopy examples:\fR
.Sp
.Vb 1
\&  $d\->open(\-url=>"host.org/dav_dir/");
.Ve
.Sp
Recursively copy dir1/ to dir2/
.Sp
.Vb 1
\&  $d\->copy(\-url=>"dir1/", \-dest=>"dir2/");
.Ve
.Sp
Non-recursively and non-forcefully copy dir1/ to dir2/
.Sp
.Vb 1
\&  $d\->copy(\-url=>"dir1/", \-dest=>"dir2/",\-overwrite=>0,\-depth=>0);
.Ve
.Sp
Create a copy of dir1/file.txt as dir2/file.txt
.Sp
.Vb 2
\&  $d\->cwd(\-url=>"dir1/");
\&  $d\->copy("file.txt","../dir2");
.Ve
.Sp
Create a copy of file.txt as dir2/new_file.txt
.Sp
.Vb 1
\&  $d\->copy("file.txt","/dav_dir/dir2/new_file.txt")
.Ve
.RE
.IP "\fBcwd(\s-1URL\s0)\fR" 4
.IX Item "cwd(URL)"
changes the remote working directory.
.Sp
This is synonymous to open except that the \s-1URL\s0 can be relative and may contain a \f(CW\*(C`glob\*(C'\fR (the first match in a glob will be used).
.Sp
.Vb 3
\&  $d\->open("host.org/dav_dir/dir1/");
\&  $d\->cwd("../dir2");
\&  $d\->cwd(\-url=>"../dir1");
.Ve
.Sp
The return value is always 1 or 0 indicating success or failure.
.Sp
Requires a working resource to be set before being called. See \f(CW\*(C`open\*(C'\fR.
.Sp
You can not cwd to files, only collections (directories).
.IP "\fBdelete(\s-1URL\s0)\fR" 4
.IX Item "delete(URL)"
deletes a remote resource.
.Sp
.Vb 4
\&  $d\->open("host.org/dav_dir/");
\&  $d\->delete("index.html");
\&  $d\->delete("./dir1");
\&  $d\->delete(\-url=>"/dav_dir/dir2/file*",\-callback=>\e&mycallback);
.Ve
.ie n .IP """\-url""" 4
.el .IP "\f(CW\-url\fR" 4
.IX Item "-url"
is the remote resource(s) you'd like to delete. It can be a file, directory or \f(CW\*(C`glob\*(C'\fR.
.ie n .IP """\-callback""                                                                                                                                                                    is a reference to a callback function which will be called everytime a file is deleted. This is mainly useful when used in conjunction with \s-1GLOBS\s0 deletes. See callbacks" 4
.el .IP "\f(CW\-callback\fR                                                                                                                                                                    is a reference to a callback function which will be called everytime a file is deleted. This is mainly useful when used in conjunction with \s-1GLOBS\s0 deletes. See callbacks" 4
.IX Item "-callback                                                                                                                                                                    is a reference to a callback function which will be called everytime a file is deleted. This is mainly useful when used in conjunction with GLOBS deletes. See callbacks"
The return value is always 1 or 0 indicating success or failure.
.Sp
Requires a working resource to be set before being called. See \f(CW\*(C`open\*(C'\fR.
.Sp
This command will recursively delete directories. \s-1BE\s0 \s-1CAREFUL\s0 of uninitialised file variables in situation like this: \f(CW$d\fR\->delete(\*(L"$dir/$file\*(R"). This will trash your \f(CW$dir\fR if \f(CW$file\fR is not set.
.IP "\fBget(\s-1URL\s0,[\s-1TO\s0],[\s-1CALLBACK\s0])\fR" 4
.IX Item "get(URL,[TO],[CALLBACK])"
downloads the file or directory at \f(CW\*(C`URL\*(C'\fR to the local location indicated by \f(CW\*(C`TO\*(C'\fR.
.RS 4
.ie n .IP """\-url""" 4
.el .IP "\f(CW\-url\fR" 4
.IX Item "-url"
is the remote resource you'd like to get. It can be a file or directory or a \*(L"glob\*(R".
.ie n .IP """\-to""" 4
.el .IP "\f(CW\-to\fR" 4
.IX Item "-to"
is where you'd like to put the remote resource. The \-to parameter can be:
.Sp
.Vb 1
\& \- a B<filename> indicating where to save the contents.
\&
\& \- a B<FileHandle reference>.
\&
\& \- a reference to a B<scalar object> into which the contents will be saved.
.Ve
.Sp
If the \f(CW\*(C`\-url\*(C'\fR matches multiple files (via a glob or a directory download), then the \f(CW\*(C`get\*(C'\fR routine will return an error if you try to use a FileHandle reference or a scalar reference.
.ie n .IP """\-callback""" 4
.el .IP "\f(CW\-callback\fR" 4
.IX Item "-callback"
is a reference to a callback function which will be called everytime a file is completed downloading. The idea of the callback function is that some recursive get's can take a very long time and the user may require some visual feedback. See \s-1CALLBACKS\s0 for an examples and how to use a callback.
.RE
.RS 4
.Sp
The return value of get is always 1 or 0 indicating whether the entire get sequence was a success or if there was \s-1ANY\s0 failures. For instance, in a recursive get, if the server couldn't open 1 of the 10 remote files, for whatever reason, then the return value will be 0. This is so that you can have your script call the \f(CW\*(C`errors()\*(C'\fR routine to handle error conditions.
.Sp
Previous versions of \s-1HTTP::DAV\s0 allowed the return value to be the file contents if no \-to attribute was supplied. This functionality is deprecated.
.Sp
Requires a working resource to be set before being called. See \f(CW\*(C`open\*(C'\fR.
.Sp
\&\fBget examples:\fR
.Sp
.Vb 1
\&  $d\->open("host.org/dav_dir/");
.Ve
.Sp
Recursively get remote my_dir/ to .
.Sp
.Vb 1
\&  $d\->get("my_dir/",".");
.Ve
.Sp
Recursively get remote my_dir/ to /tmp/my_dir/ calling &mycallback($success,$mesg) everytime a file operation is completed.
.Sp
.Vb 1
\&  $d\->get("my_dir","/tmp",\e&mycallback);
.Ve
.Sp
Get remote my_dir/index.html to /tmp/index.html
.Sp
.Vb 1
\&  $d\->get(\-url=>"/dav_dir/my_dir/index.html",\-to=>"/tmp");
.Ve
.Sp
Get remote index.html to /tmp/index1.html
.Sp
.Vb 1
\&  $d\->get("index.html","/tmp/index1.html");
.Ve
.Sp
Get remote index.html to a filehandle
.Sp
.Vb 3
\&  my $fh = new FileHandle;
\&  $fh\->open(">/tmp/index1.html");
\&  $d\->get("index.html",\e$fh);
.Ve
.Sp
Get remote index.html as a scalar (into the string \f(CW$file_contents\fR):
.Sp
.Vb 2
\&  my $file_contents;
\&  $d\->get("index.html",\e$file_contents);
.Ve
.Sp
Get all of the files matching the globs file1* and file2*:
.Sp
.Vb 1
\&  $d\->get("file[12]*","/tmp");
.Ve
.Sp
Get all of the files matching the glob file?.html:
.Sp
.Vb 1
\&  $d\->get("file?.html","/tmp"); # downloads file1.html and file2.html but not file3.html or file1.txt
.Ve
.Sp
Invalid glob:
.Sp
.Vb 1
\&  $d\->get("/dav_dir/*/index.html","/tmp"); # Can not glob like this.
.Ve
.RE
.IP "\fBlock([\s-1URL\s0],[\s-1OWNER\s0],[\s-1DEPTH\s0],[\s-1TIMEOUT\s0],[\s-1SCOPE\s0],[\s-1TYPE\s0])\fR" 4
.IX Item "lock([URL],[OWNER],[DEPTH],[TIMEOUT],[SCOPE],[TYPE])"
locks a resource. If \s-1URL\s0 is not specified, it will lock the current working resource (opened resource).
.Sp
.Vb 6
\&   $d\->lock( \-url     => "index.html",
\&             \-owner   => "Patrick Collins",
\&             \-depth   => "infinity",
\&             \-scope   => "exclusive",
\&             \-type    => "write",
\&             \-timeout => "10h" )
.Ve
.Sp
See \f(CW\*(C`HTTP::DAV::Resource\*(C'\fR \fIlock()\fR for details of the above parameters.
.Sp
The return value is always 1 or 0 indicating success or failure.
.Sp
Requires a working resource to be set before being called. See \f(CW\*(C`open\*(C'\fR.
.Sp
When you lock a resource, the lock is held against the current \s-1HTTP::DAV\s0 object. In fact, the locks are held in a \f(CW\*(C`HTTP::DAV::ResourceList\*(C'\fR object. You can operate against all of the locks that you have created as follows:
.Sp
.Vb 11
\&  ## Print and unlock all locks that we own.
\&  my $rl_obj = $d\->get_lockedresourcelist();
\&  foreach $resource ( $rl_obj\->get_resources() ) {
\&      @locks = $resource\->get_locks(\-owned=>1);
\&      foreach $lock ( @locks ) { 
\&        print $resource\->get_uri . "\en";
\&        print $lock\->as_string . "\en";
\&      }
\&      ## Unlock them?
\&      $resource\->unlock;
\&  }
.Ve
.Sp
Typically, a simple \f(CW$d\fR\->unlock($uri) will suffice.
.Sp
\&\fBlock example\fR
.Sp
.Vb 4
\&  $d\->lock($uri, \-timeout=>"1d");
\&  ...
\&  $d\->put("/tmp/index.html",$uri);
\&  $d\->unlock($uri);
.Ve
.IP "\fBmkcol(\s-1URL\s0)\fR" 4
.IX Item "mkcol(URL)"
make a remote collection (directory)
.Sp
The return value is always 1 or 0 indicating success or failure.
.Sp
Requires a working resource to be set before being called. See \f(CW\*(C`open\*(C'\fR.
.Sp
.Vb 4
\&  $d\->open("host.org/dav_dir/");
\&  $d\->mkcol("new_dir");                  # Should succeed
\&  $d\->mkcol("/dav_dir/new_dir");         # Should succeed
\&  $d\->mkcol("/dav_dir/new_dir/xxx/yyy"); # Should fail
.Ve
.IP "\fBmove(\s-1URL\s0,DEST,[\s-1OVERWRITE\s0],[\s-1DEPTH\s0])\fR" 4
.IX Item "move(URL,DEST,[OVERWRITE],[DEPTH])"
moves one remote resource to another
.RS 4
.ie n .IP """\-url""" 4
.el .IP "\f(CW\-url\fR" 4
.IX Item "-url"
is the remote resource you'd like to move. Mandatory
.ie n .IP """\-dest""" 4
.el .IP "\f(CW\-dest\fR" 4
.IX Item "-dest"
is the remote target for the move command. Mandatory
.ie n .IP """\-overwrite""" 4
.el .IP "\f(CW\-overwrite\fR" 4
.IX Item "-overwrite"
optionally indicates whether the server should fail if the target exists. Valid values are \*(L"T\*(R" and \*(L"F\*(R" (1 and 0 are synonymous). Default is T.
.RE
.RS 4
.Sp
Requires a working resource to be set before being called. See \f(CW\*(C`open\*(C'\fR.
.Sp
The return value is always 1 or 0 indicating success or failure.
.Sp
Note: if either \f(CW\*(AqURL\*(Aq\fR or \f(CW\*(AqDEST\*(Aq\fR are locked by this dav client, then the lock headers will be taken care of automatically. If either of the two \s-1URL\s0's are locked by someone else, the server should reject the request.
.Sp
\&\fBmove examples:\fR
.Sp
.Vb 1
\&  $d\->open(\-url=>"host.org/dav_dir/");
.Ve
.Sp
move dir1/ to dir2/
.Sp
.Vb 1
\&  $d\->move(\-url=>"dir1/", \-dest=>"dir2/");
.Ve
.Sp
non-forcefully move dir1/ to dir2/
.Sp
.Vb 1
\&  $d\->move(\-url=>"dir1/", \-dest=>"dir2/",\-overwrite=>0);
.Ve
.Sp
Move dir1/file.txt to dir2/file.txt
.Sp
.Vb 2
\&  $d\->cwd(\-url=>"dir1/");
\&  $d\->move("file.txt","../dir2");
.Ve
.Sp
move file.txt to dir2/new_file.txt
.Sp
.Vb 1
\&  $d\->move("file.txt","/dav_dir/dir2/new_file.txt")
.Ve
.RE
.IP "\fBopen(\s-1URL\s0)\fR" 4
.IX Item "open(URL)"
opens the directory (collection resource) at \s-1URL\s0.
.Sp
open will perform a propfind against \s-1URL\s0. If the server does not understand the request then the open will fail.
.Sp
Similarly, if the server indicates that the resource at \s-1URL\s0 is \s-1NOT\s0 a collection, the open command will fail.
.IP "\fBoptions([\s-1URL\s0])\fR" 4
.IX Item "options([URL])"
Performs an \s-1OPTIONS\s0 request against the \s-1URL\s0 or the working resource if \s-1URL\s0 is not supplied.
.Sp
Requires a working resource to be set before being called. See \f(CW\*(C`open\*(C'\fR.
.Sp
The return value is a string of comma separated \s-1OPTIONS\s0 that the server states are legal for \s-1URL\s0 or undef otherwise.
.Sp
A fully compliant \s-1DAV\s0 server may offer as many methods as: \s-1OPTIONS\s0, \s-1TRACE\s0, \s-1GET\s0, \s-1HEAD\s0, \s-1DELETE\s0, \s-1PUT\s0, \s-1COPY\s0, \s-1MOVE\s0, \s-1PROPFIND\s0, \s-1PROPPATCH\s0, \s-1LOCK\s0, \s-1UNLOCK\s0
.Sp
Note: \s-1IIS5\s0 does not support \s-1PROPPATCH\s0 or \s-1LOCK\s0 on collections.
.Sp
Example:
.Sp
.Vb 5
\& $options = $d\->options($url);
\& print $options . "\en";
\& if ($options=~ /\ebPROPPATCH\eb/) {
\&    print "OK to proppatch\en";
\& }
.Ve
.Sp
Or, put more simply:
.Sp
.Vb 3
\& if ( $d\->options($url) =~ /\ebPROPPATCH\eb/ ) {
\&    print "OK to proppatch\en";
\& }
.Ve
.IP "\fBpropfind([\s-1URL\s0],[\s-1DEPTH\s0])\fR" 4
.IX Item "propfind([URL],[DEPTH])"
Perform a propfind against \s-1URL\s0 at \s-1DEPTH\s0 depth.
.Sp
\&\f(CW\*(C`\-depth\*(C'\fR can be used to specify how deep the propfind goes. \*(L"0\*(R" is collection only. \*(L"1\*(R" is collection and it's immediate members (This is the default value). \*(L"infinity\*(R" is the entire directory tree. Note that most \s-1DAV\s0 compliant servers deny \*(L"infinity\*(R" depth propfinds for security reasons.
.Sp
Requires a working resource to be set before being called. See \f(CW\*(C`open\*(C'\fR.
.Sp
The return value is an \f(CW\*(C`HTTP::DAV::Resource\*(C'\fR object on success or 0 on failure.
.Sp
The Resource object can be used for interrogating properties or performing other operations.
.Sp
.Vb 9
\& ## Print collection or content length
\& if ( $r=$d\->propfind( \-url=>"/my_dir", \-depth=>1) ) {
\&    if ( $r\->is_collection ) {
\&       print "Collection\en" 
\&       print $r\->get_resourcelist\->as_string . "\en"
\&    } else {
\&       print $r\->get_property("getcontentlength") ."\en";
\&    }
\& }
.Ve
.Sp
Please note that although you may set a different namespace for a property of a resource during a set_prop, \s-1HTTP::DAV\s0 currently ignores all \s-1XML\s0 namespaces so you will get clashes if two properties have the same name but in different namespaces. Currently this is unavoidable but I'm working on the solution.
.IP "\fBproppatch([\s-1URL\s0],[\s-1NAMESPACE\s0],PROPNAME,PROPVALUE,ACTION,[\s-1NSABBR\s0])\fR" 4
.IX Item "proppatch([URL],[NAMESPACE],PROPNAME,PROPVALUE,ACTION,[NSABBR])"
If \f(CW\*(C`\-action\*(C'\fR equals \*(L"set\*(R" then we set a property named \f(CW\*(C`\-propname\*(C'\fR to \f(CW\*(C`\-propvalue\*(C'\fR in the namespace \f(CW\*(C`\-namespace\*(C'\fR for \f(CW\*(C`\-url\*(C'\fR.
.Sp
If \f(CW\*(C`\-action\*(C'\fR equals \*(L"remove\*(R" then we unset a property named \f(CW\*(C`\-propname\*(C'\fR in the namespace \f(CW\*(C`\-namespace\*(C'\fR for \f(CW\*(C`\-url\*(C'\fR.
.Sp
If no action is supplied then the default action is \*(L"set\*(R".
.Sp
The return value is an \f(CW\*(C`HTTP::DAV::Resource\*(C'\fR object on success or 0 on failure.
.Sp
The Resource object can be used for interrogating properties or performing other operations.
.Sp
To explicitly set a namespace in which to set the propname then you can use the \f(CW\*(C`\-namespace\*(C'\fR and \f(CW\*(C`\-nsabbr\*(C'\fR (namespace abbreviation) parameters. But you're welcome to play around with \s-1DAV\s0 namespaces.
.Sp
Requires a working resource to be set before being called. See \f(CW\*(C`open\*(C'\fR.
.Sp
It is recommended that you use \f(CW\*(C`set_prop\*(C'\fR and \f(CW\*(C`unset_prop\*(C'\fR instead of proppatch for readability.
.Sp
\&\f(CW\*(C`set_prop\*(C'\fR simply calls \f(CW\*(C`proppatch(\-action=\*(C'\fRset)> and \f(CW\*(C`unset_prop\*(C'\fR calls \f(CW\*(C`proppatch(\-action=\*(C'\fR\*(L"remove\*(R")>
.Sp
See \f(CW\*(C`set_prop\*(C'\fR and \f(CW\*(C`unset_prop\*(C'\fR for examples.
.IP "\fBput(\s-1LOCAL\s0,[\s-1URL\s0],[\s-1CALLBACK\s0],[\s-1HEADERS\s0])\fR" 4
.IX Item "put(LOCAL,[URL],[CALLBACK],[HEADERS])"
uploads the files or directories at \f(CW\*(C`\-local\*(C'\fR to the remote destination at \f(CW\*(C`\-url\*(C'\fR.
.Sp
\&\f(CW\*(C`\-local\*(C'\fR points to a file, directory or series of files or directories (indicated by a glob).
.Sp
If the filename contains any of the characters `*',  `?' or  `['  it is a candidate for filename substitution, also  known  as  ``globbing''.   This word  is  then regarded as a pattern (``glob\-pattern''), and replaced with an alphabetically sorted list  of  file  names which match the pattern.
.Sp
One can upload/put a string by passing a reference to a scalar in the \-local parameter. See example below.
.Sp
put requires a working resource to be set before being called. See \f(CW\*(C`open\*(C'\fR.
.Sp
The return value is always 1 or 0 indicating success or failure.
.Sp
See \fIget()\fR for a description of what the optional callback parameter does.
.Sp
You can also pass a \f(CW\*(C`\-headers\*(C'\fR argument. That allows to specify custom \s-1HTTP\s0 headers. It can be either a hashref with header names and values, or a HTTP::Headers object.
.Sp
\&\fBput examples:\fR
.Sp
Put a string to the server:
.Sp
.Vb 2
\&  my $myfile = "This is the contents of a file to be uploaded\en";
\&  $d\->put(\-local=>\e$myfile,\-url=>"http://www.host.org/dav_dir/file.txt");
.Ve
.Sp
Put a local file to the server:
.Sp
.Vb 1
\&  $d\->put(\-local=>"/tmp/index.html",\-url=>"http://www.host.org/dav_dir/");
.Ve
.Sp
Put a series of local files to the server:
.Sp
.Vb 2
\&  In these examples, /tmp contains file1.html, file1, file2.html, 
\&  file2.txt, file3.html, file2/
\&
\&  $d\->put(\-local=>"/tmp/file[12]*",\-url=>"http://www.host.org/dav_dir/");
\&  
\&  uploads file1.html, file1, file2.html, file2.txt and the directory file2/ to dav_dir/.
.Ve
.IP "\fBset_prop([\s-1URL\s0],[\s-1NAMESPACE\s0],PROPNAME,PROPVALUE)\fR" 4
.IX Item "set_prop([URL],[NAMESPACE],PROPNAME,PROPVALUE)"
Sets a property named \f(CW\*(C`\-propname\*(C'\fR to \f(CW\*(C`\-propvalue\*(C'\fR in the namespace \f(CW\*(C`\-namespace\*(C'\fR for \f(CW\*(C`\-url\*(C'\fR.
.Sp
Requires a working resource to be set before being called. See \f(CW\*(C`open\*(C'\fR.
.Sp
The return value is an \f(CW\*(C`HTTP::DAV::Resource\*(C'\fR object on success or 0 on failure.
.Sp
The Resource object can be used for interrogating properties or performing other operations.
.Sp
Example:
.Sp
.Vb 9
\& if ( $r = $d\->set_prop(\-url=>$url,
\&              \-namespace=>"dave",
\&              \-propname=>"author",
\&              \-propvalue=>"Patrick Collins"
\&             ) ) {
\&    print "Author property set\en";
\& } else {
\&    print "set_prop failed:" . $d\->message . "\en";
\& }
.Ve
.Sp
See the note in propfind about namespace support in \s-1HTTP::DAV\s0. They're settable, but not readable.
.IP "\fBsteal([\s-1URL\s0])\fR" 4
.IX Item "steal([URL])"
forcefully steals any locks held against \s-1URL\s0.
.Sp
steal will perform a propfind against \s-1URL\s0 and then, any locks that are found will be unlocked one by one regardless of whether we own them or not.
.Sp
Requires a working resource to be set before being called. See \f(CW\*(C`open\*(C'\fR.
.Sp
The return value is always 1 or 0 indicating success or failure. If multiple locks are found and unlocking one of them fails then the operation will be aborted.
.Sp
.Vb 5
\& if ($d\->steal()) {
\&    print "Steal succeeded\en";
\& } else {
\&    print "Steal failed: ". $d\->message() . "\en";
\& }
.Ve
.IP "\fBunlock([\s-1URL\s0])\fR" 4
.IX Item "unlock([URL])"
unlocks any of our locks on \s-1URL\s0.
.Sp
Requires a working resource to be set before being called. See \f(CW\*(C`open\*(C'\fR.
.Sp
The return value is always 1 or 0 indicating success or failure.
.Sp
.Vb 5
\& if ($d\->unlock()) {
\&    print "Unlock succeeded\en";
\& } else {
\&    print "Unlock failed: ". $d\->message() . "\en";
\& }
.Ve
.IP "\fBunset_prop([\s-1URL\s0],[\s-1NAMESPACE\s0],PROPNAME)\fR" 4
.IX Item "unset_prop([URL],[NAMESPACE],PROPNAME)"
Unsets a property named \f(CW\*(C`\-propname\*(C'\fR in the namespace \f(CW\*(C`\-namespace\*(C'\fR for \f(CW\*(C`\-url\*(C'\fR. 
Requires a working resource to be set before being called. See \f(CW\*(C`open\*(C'\fR.
.Sp
The return value is an \f(CW\*(C`HTTP::DAV::Resource\*(C'\fR object on success or 0 on failure.
.Sp
The Resource object can be used for interrogating properties or performing other operations.
.Sp
Example:
.Sp
.Vb 8
\& if ( $r = $d\->unset_prop(\-url=>$url,
\&              \-namespace=>"dave",
\&              \-propname=>"author",
\&             ) ) {
\&    print "Author property was unset\en";
\& } else {
\&    print "set_prop failed:" . $d\->message . "\en";
\& }
.Ve
.Sp
See the note in propfind about namespace support in \s-1HTTP::DAV\s0. They're settable, but not readable.
.SS "\s-1ACCESSOR\s0 \s-1METHODS\s0"
.IX Subsection "ACCESSOR METHODS"
.IP "\fBget_user_agent\fR" 4
.IX Item "get_user_agent"
Returns the clients' working \f(CW\*(C`HTTP::DAV::UserAgent\*(C'\fR object.
.Sp
You may want to interact with the \f(CW\*(C`HTTP::DAV::UserAgent\*(C'\fR object 
to modify request headers or provide advanced authentication 
procedures. See dave for an advanced authentication procedure.
.IP "\fBget_last_request\fR" 4
.IX Item "get_last_request"
Takes no arguments and returns the clients' last outgoing \f(CW\*(C`HTTP::Request\*(C'\fR object.
.Sp
You would only use this to inspect a request that has already occurred.
.Sp
If you would like to modify the \f(CW\*(C`HTTP::Request\*(C'\fR \s-1BEFORE\s0 the \s-1HTTP\s0 request takes place (for instance to add another header), you will need to get the \f(CW\*(C`HTTP::DAV::UserAgent\*(C'\fR using \f(CW\*(C`get_user_agent\*(C'\fR and interact with that.
.IP "\fBget_workingresource\fR" 4
.IX Item "get_workingresource"
Returns the currently \*(L"opened\*(R" or \*(L"working\*(R" resource (\f(CW\*(C`HTTP::DAV::Resource\*(C'\fR).
.Sp
The working resource is changed whenever you open a url or use the cwd command.
.Sp
e.g. 
  \f(CW$r\fR = \f(CW$d\fR\->get_workingresource
  print \*(L"pwd: \*(R" . \f(CW$r\fR\->get_uri . \*(L"\en\*(R";
.IP "\fBget_workingurl\fR" 4
.IX Item "get_workingurl"
Returns the currently \*(L"opened\*(R" or \*(L"working\*(R" \f(CW\*(C`URL\*(C'\fR.
.Sp
The working resource is changed whenever you open a url or use the cwd command.
.Sp
.Vb 1
\&  print "pwd: " . $d\->get_workingurl . "\en";
.Ve
.IP "\fBget_lockedresourcelist\fR" 4
.IX Item "get_lockedresourcelist"
Returns an \f(CW\*(C`HTTP::DAV::ResourceList\*(C'\fR object that represents all of the locks we've created using \s-1THIS\s0 dav client.
.Sp
.Vb 1
\&  print "pwd: " . $d\->get_workingurl . "\en";
.Ve
.IP "\fBget_absolute_uri(\s-1REL_URI\s0,[\s-1BASE_URI\s0])\fR" 4
.IX Item "get_absolute_uri(REL_URI,[BASE_URI])"
This is a useful utility function which joins \f(CW\*(C`BASE_URI\*(C'\fR and \f(CW\*(C`REL_URI\*(C'\fR and returns a new \s-1URI\s0.
.Sp
If \f(CW\*(C`BASE_URI\*(C'\fR is not supplied then the current working resource (as indicated by get_workingurl) is used. If \f(CW\*(C`BASE_URI\*(C'\fR is not set and there is no current working resource the \f(CW\*(C`REL_URI\*(C'\fR will be returned.
.Sp
For instance:
 \f(CW$d\fR\->open(\*(L"http://host.org/webdav/dir1/\*(R");
.Sp
.Vb 2
\& # Returns "http://host.org/webdav/dir2/"
\& $d\->get_absolute_uri(\-rel_uri=>"../dir2");
\&
\& # Returns "http://x.org/dav/dir2/file.txt"
\& $d\->get_absolute_uri(\-rel_uri  =>"dir2/file.txt",
\&                      \->base_uri=>"http://x.org/dav/");
.Ve
.Sp
Note that it subtly takes care of trailing slashes.
.SS "\s-1ERROR\s0 \s-1HANDLING\s0 \s-1METHODS\s0"
.IX Subsection "ERROR HANDLING METHODS"
.IP "\fBmessage\fR" 4
.IX Item "message"
\&\f(CW\*(C`message\*(C'\fR gets the last success or error message.
.Sp
The return value is always a scalar (string) and will change everytime a dav operation is invoked (lock, cwd, put, etc).
.Sp
See also \f(CW\*(C`errors\*(C'\fR for operations which contain multiple error messages.
.IP "\fBerrors\fR" 4
.IX Item "errors"
Returns an \f(CW@array\fR of error messages that had been set during a multi-request operation.
.Sp
Some of \f(CW\*(C`HTTP::DAV\*(C'\fR's operations perform multiple request to the server. At the time of writing only put and get are considered multi-request since they can operate recursively requiring many \s-1HTTP\s0 requests.
.Sp
In these situations you should check the errors array if to determine if any of the requests failed.
.Sp
The \f(CW\*(C`errors\*(C'\fR function is used for multi-request operations and not to be confused with a multi-status server response. A multi-status server response is when the server responds with multiple error messages for a \s-1SINGLE\s0 request. To deal with multi-status responses, see \f(CW\*(C`HTTP::DAV::Response\*(C'\fR.
.Sp
.Vb 7
\& # Recursive put
\& if (!$d\->put( "/tmp/my_dir", $url ) ) {
\&    # Get the overall message
\&    print $d\->message;
\&    # Get the individual messages
\&    foreach $err ( $d\->errors ) { print "  Error:$err\en" }
\& }
.Ve
.IP "\fBis_success\fR" 4
.IX Item "is_success"
Returns the status of the last \s-1DAV\s0 operation performed through the \s-1HTTP::DAV\s0 interface.
.Sp
This value will always be the same as the value returned from an HTTP::DAV::method. For instance:
.Sp
.Vb 2
\&  # This will always evaluate to true
\&  ($d\->lock($url) eq $d\->is_success) ?
.Ve
.Sp
You may want to use the is_success method if you didn't capture the return value immediately. But in most circumstances you're better off just evaluating as follows:
  if($d\->lock($url)) { ... }
.IP "\fBget_last_response\fR" 4
.IX Item "get_last_response"
Takes no arguments and returns the last seen \f(CW\*(C`HTTP::DAV::Response\*(C'\fR object.
.Sp
You may want to use this if you have just called a propfind and need the individual error messages returned in a MultiStatus.
.Sp
If you find that you're using \fIget_last_response()\fR method a lot, you may be better off using the more advanced \f(CW\*(C`HTTP::DAV\*(C'\fR interface and interacting with the HTTP::DAV::* interfaces directly as discussed in the intro. For instance, if you find that you're always wanting a detailed understanding of the server's response headers or messages, then you're probably better off using the \f(CW\*(C`HTTP::DAV::Resource\*(C'\fR methods and interpreting the \f(CW\*(C`HTTP::DAV::Response\*(C'\fR directly.
.Sp
To perform detailed analysis of the server's response (if for instance you got back a multistatus response) you can call \f(CW\*(C`get_last_response()\*(C'\fR which will return to you the most recent response object (always the result of the last operation, \s-1PUT\s0, \s-1PROPFIND\s0, etc). With the returned HTTP::DAV::Response object you can handle multi-status responses.
.Sp
For example:
.Sp
.Vb 11
\&   # Print all of the messages in a multistatus response
\&   if (! $d\->unlock($url) ) {
\&      $response = $d\->get_last_response();
\&      if ($response\->is_multistatus() ) {
\&        foreach $num ( 0 .. $response\->response_count() ) {
\&           ($err_code,$mesg,$url,$desc) =
\&              $response\->response_bynum($num);
\&           print "$mesg ($err_code) for $url\en";
\&        }
\&      }
\&   }
.Ve
.SS "\s-1ADVANCED\s0 \s-1METHODS\s0"
.IX Subsection "ADVANCED METHODS"
.IP "\fBnew_resource\fR" 4
.IX Item "new_resource"
Creates a new resource object with which to play.
This is the preferred way of creating an \f(CW\*(C`HTTP::DAV::Resource\*(C'\fR object if required.
Why? Because each Resource object needs to sit within a global \s-1HTTP::DAV\s0 client. 
Also, because the new_resource routine checks the \f(CW\*(C`HTTP::DAV\*(C'\fR locked resource
list before creating a new object.
.Sp
.Vb 1
\&    $dav\->new_resource( \-uri => "http://..." );
.Ve
.IP "\fBset_workingresource(\s-1URL\s0)\fR" 4
.IX Item "set_workingresource(URL)"
Sets the current working resource to \s-1URL\s0.
.Sp
You shouldn't need this method. Call open or cwd to set the working resource.
.Sp
You \s-1CAN\s0 call \f(CW\*(C`set_workingresource()\*(C'\fR but you will need to perform a
\&\f(CW\*(C`propfind\*(C'\fR immediately following it to ensure that the working
resource is valid.
.SH "INSTALLATION, TODO, MAILING LISTS and REVISION HISTORY"
.IX Header "INSTALLATION, TODO, MAILING LISTS and REVISION HISTORY"
[\s-1OUTDATED\s0]
.PP
Please see the primary \s-1HTTP::DAV\s0 webpage at
(http://www.webdav.org/perldav/http\-dav/)
or the \s-1README\s0 file in this library.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
You'll want to also read:
.ie n .IP """HTTP::DAV::Response""" 4
.el .IP "\f(CWHTTP::DAV::Response\fR" 4
.IX Item "HTTP::DAV::Response"
.PD 0
.ie n .IP """HTTP::DAV::Resource""" 4
.el .IP "\f(CWHTTP::DAV::Resource\fR" 4
.IX Item "HTTP::DAV::Resource"
.ie n .IP """dave""" 4
.el .IP "\f(CWdave\fR" 4
.IX Item "dave"
.PD
.PP
and maybe if you're more inquisitive:
.ie n .IP """LWP::UserAgent""" 4
.el .IP "\f(CWLWP::UserAgent\fR" 4
.IX Item "LWP::UserAgent"
.PD 0
.ie n .IP """HTTP::Request""" 4
.el .IP "\f(CWHTTP::Request\fR" 4
.IX Item "HTTP::Request"
.ie n .IP """HTTP::DAV::Comms""" 4
.el .IP "\f(CWHTTP::DAV::Comms\fR" 4
.IX Item "HTTP::DAV::Comms"
.ie n .IP """HTTP::DAV::Lock""" 4
.el .IP "\f(CWHTTP::DAV::Lock\fR" 4
.IX Item "HTTP::DAV::Lock"
.ie n .IP """HTTP::DAV::ResourceList""" 4
.el .IP "\f(CWHTTP::DAV::ResourceList\fR" 4
.IX Item "HTTP::DAV::ResourceList"
.ie n .IP """HTTP::DAV::Utils""" 4
.el .IP "\f(CWHTTP::DAV::Utils\fR" 4
.IX Item "HTTP::DAV::Utils"
.PD
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
This module is Copyright (C) 2001\-2008 by
.PP
.Vb 3
\&    Patrick Collins
\&    G03 Gloucester Place, Kensington
\&    Sydney, Australia
\&
\&    Email: pcollins@cpan.org
\&    Phone: +61 2 9663 4916
.Ve
.PP
All rights reserved.
.PP
Current co-maintainer of the module is Cosimo Streppone
for Opera Software \s-1ASA\s0, opera@cpan.org.
.PP
You may distribute this module under the terms of either the
\&\s-1GNU\s0 General Public License or the Artistic License,
as specified in the Perl \s-1README\s0 file.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 2048:" 4
.IX Item "Around line 2048:"
=over should be: '=over' or '=over positive_number'
.IP "Around line 2060:" 4
.IX Item "Around line 2060:"
=over should be: '=over' or '=over positive_number'
